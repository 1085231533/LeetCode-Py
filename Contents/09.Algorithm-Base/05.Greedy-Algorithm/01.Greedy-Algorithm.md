## 1. 贪心算法简介

### 1.1 贪心算法的定义

> **贪心算法（Greedy Algorithm）**：一种在每次决策时，总是采取在当前状态下的最好选择，从而希望导致结果是最好或最优的算法。

贪心算法是一种改进的「分步解决算法」，其核心思想是：将求解过程分成「若干个步骤」，然后根据题意选择一种「度量标准」，每个步骤都应用「贪心原则」，选取当前状态下「最好 / 最优选择（局部最优解）」，并以此希望最后得出的结果也是「最好 / 最优结果（全局最优解）」。

换句话说，贪心算法不从整体最优上加以考虑，而是一步一步进行，每一步只以当前情况为基础，根据某个优化测度做出局部最优选择，从而省去了为找到最优解要穷举所有可能所必须耗费的大量时间。

当然，使用贪心算法所得到的最终解并不一定就是全局最优解。但是对许多问题来说，确实可以通过局部最优解而得到整体最优解或者是整体最优解的近似解。

一般来说，这些能够使用贪心算法解决的问题必须满足下面的两个特征：「贪⼼选择性质」和「最优子结构」。

### 1.2 贪心算法的特征

#### 1.2.1 贪心选择性质

「贪心选择」：指的是一个问题的全局最优解可以通过一系列局部最优解（贪心选择）来得到。

换句话说，当进行选择时，我们直接做出在当前问题中看来最优的选择，而不用去考虑子问题的解。在做出选择之后，才会去求解剩下的子问题，如下图所示。

![](https://qcdn.itcharge.cn/images/20220511174939.png)

贪心算法在进行选择时，可能会依赖之前做出的选择，但不会依赖任何将来的选择或是子问题的解。运用贪心算法解决的问题在程序的运行过程中无回溯过程。

#### 1.2.2 最优子结构性质

「最优子结构」：指的是一个问题的最优解包含其子问题的最优解。

问题的最优子结构性质是该问题能否用贪心算法求解的关键。举个例子，如下图所示，原问题 $S = \left\{ a_1, a_2, a_3, a_4 \right\}$，在 $a_1$ 步我们通过贪心选择选出一个当前最优解之后，问题就转换为求解子问题 $S_{子问题} = \left\{ a_2, a_3, a_4 \right\}$。如果原问题 $S$ 的最优解可以由「第 $a_1$ 步通过贪心选择的局部最优解」和「 $S_{子问题}$ 的最优解」构成，则说明该问题满足最优子结构性质。

也就是说，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质。

![](https://qcdn.itcharge.cn/images/20220511175042.png)

在做了贪心选择后，满足最优子结构性质的原问题可以分解成规模更小的类似子问题来解决，并且可以通过贪心选择和子问题的最优解推导出问题的最优解。

反之，如果不能利用子问题的最优解推导出整个问题的最优解，那么这种问题就不具有最优子结构。

### 1.3 贪心算法正确性的证明

贪心算法最难的部分不在于问题的求解，而在于是正确性的证明。常用的证明方法有「数学归纳法」和「交换论证法」。

- **数学归纳法**：先计算出边界情况（例如 $n = 1$）的最优解，然后再证明对于每个 $n$，$F_{n + 1}$ 都可以由 $F_n$ 推导出。
- **交换论证法**：从最优解出发，在保证全局最优不变的前提下，如果交换方案中任意两个元素 / 相邻的两个元素后，答案不会变得更好，则可以推定目前的解是最优解。

判断一个问题是否通过贪心算法求解，是需要进行严格的数学证明的。但是在日常写题或者算法面试中，不太会要求大家去证明贪心算法的正确性。

所以，当我们想要判断一个问题是否通过贪心算法求解时，我们可以：

1. **凭直觉**：如果感觉这道题可以通过「贪心算法」去做，就尝试找到局部最优解，再推导出全局最优解。
2. **举反例**：尝试一下，举出反例。也就是说找出一个局部最优解推不出全局最优解的例子，或者找出一个替换当前子问题的最优解，可以得到更优解的例子。如果举不出反例，大概率这道题是可以通过贪心算法求解的。

## 3. 贪心算法三步走

1. **转换问题**：将优化问题转换为具有贪心选择性质的问题，即先做出选择，再解决剩下的一个子问题。
2. **贪心策略**：根据题意选择一种度量标准，制定贪心策略，选取当前状态下「最好 / 最优选择」，从而得到局部最优解。
3. **全局最优解**：根据上一步制定的贪心策略，将贪心选择的局部最优解和子问题的最优解合并起来，得到原问题的最优解。

1. **贪⼼策略**：指确定贪⼼策略，选择当前看上去最好的⼀个。 ⽐如挑选苹果，如果你认为个头⼤的是最好的，那么每次都从苹果堆 中拿⼀个最⼤的作为局部最优解， 贪⼼策略就是选择当前最⼤的苹 果。如果你认为最红的苹果是最好的，那么每次都从苹果堆中拿⼀个 最红的，贪⼼策略就是选择当前最红的苹果。因此根据求解⽬标的不 同，贪⼼策略也会不同。
2. **局部最优解**：指根据贪⼼策略，⼀步步地得到局部最优解。 ⽐如第 1 次选⼀个最⼤的苹果放起来，记为a 1 ；第2次再从剩下的苹果 中选择⼀个最⼤的苹果放起来，记为a 2 ，以此类推。
3. **全局最优解**：指把所有的局部最优解都合成原问题的⼀个最优解{a 1 ,a 2 ……}。

1. 建立数学模型来描述问题；
2. 把求解的问题分成若干个子问题；
3. 对每一子问题求解，得到子问题的局部最优解；
4. 把子问题的解局部最优解合成原来解问题的一个解。

## 4. 贪心算法的应用

### 4.1 分发饼干

#### 4.1.1 题目链接

- [455. 分发饼干 - 力扣](https://leetcode.cn/problems/assign-cookies/)

#### 4.1.2 题目大意

**描述**：一位很棒的家长为孩子们分发饼干。对于每个孩子 `i`，都有一个胃口值 `g[i]`，即每个小孩希望得到饼干的最小尺寸值。对于每块饼干 `j`，都有一个尺寸值 `s[j]`。只有当 `s[j] > g[i]` 时，我们才能将饼干 `j` 分配给孩子 `i`。每个孩子最多只能给一块饼干。

现在给定代表所有孩子胃口值的数组 `g` 和代表所有饼干尺寸的数组 `j`。

**要求**：尽可能满足越多数量的孩子，并求出这个最大数值。

**说明**：

- $1 \le g.length \le 3 * 10^4$。
- $0 \le s.length \le 3 * 10^4$。
- $1 \le g[i], s[j] \le 2^{31} - 1$。

**示例**：

```Python
输入    g = [1,2,3], s = [1,1]
输出    1
解释    你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以应该输出 1。
```

#### 4.1.3 解题思路

为了尽可能的满⾜更多的⼩孩，而且一块饼干不能掰成两半，所以我们应该尽量让胃口小的孩子吃小块饼干，这样胃口大的孩子才有大块饼干吃。

所以，从贪心算法的角度来考虑，我们应该按照孩子的胃口从小到大对数组 `g` 进行排序，然后按照饼干的尺寸大小从小到大对数组 `s` 进行排序，并且对于每个孩子，应该选择满足这个孩子的胃口且尺寸最小的饼干。

下面我们使用贪心算法三步走的方法解决这道题。

1. **转换问题**：将原问题转变为，当胃口最小的孩子选择完满足这个孩子的胃口且尺寸最小的饼干之后，再解决剩下孩子的选择问题（子问题）。
2. **贪心策略**：对于当前孩子，用尺寸尽可能小的饼干满足这个孩子的胃口。
3. **全局最优解**：在上面的贪心策略下，满足胃口的孩子数量达到最大，就是全局最优解。

使用贪心算法的代码解决步骤描述如下：

1. 对数组 `g`、`s` 进行从小到大排序，使用变量 `index_g` 和 `index_s` 分别指向 `g`、`s` 初始位置，使用变量 `res` 保存结果，初始化为 `0`。
2. 对比每个元素 `g[index_g]` 和 `s[index_s]`：
   1. 如果 `g[index_g] <= s[index_s]`，说明当前饼干满足当前孩子胃口，则答案数量加 `1`，并且向右移动 `index_g` 和 `index_s`。
   2. 如果 `g[index_g] > s[index_s]`，说明当前饼干无法满足当前孩子胃口，则向右移动 `index_s`，判断下一块饼干是否可以满足当前孩子胃口。
3. 遍历完输出答案 `res`。

#### 4.1.4 代码

```Python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        index_g, index_s = 0, 0
        res = 0
        while index_g < len(g) and index_s < len(s):
            if g[index_g] <= s[index_s]:
                res += 1
                index_g += 1
                index_s += 1
            else:
                index_s += 1   

        return res
```



## 参考资料

- 【博文】[贪心 - OI Wiki](https://oi-wiki.org/basic/greedy/)
- 【博文】[贪心算法理论基础 - Carl - 代码随想录](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/贪心算法理论基础.md)
- 【书籍】算法导论 第三版（中文版）- 殷建平等 译
- 【书籍】ACM-ICPC 程序设计系列 - 算法设计与实现 - 陈宇 吴昊 主编