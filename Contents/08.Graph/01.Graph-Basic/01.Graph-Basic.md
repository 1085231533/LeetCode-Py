

## 1. 图的定义

> **图（Graph）**：由顶点的非空有限集合 V （由 $n > 0$ 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 $G = (V, E)$。

- **顶点（Vertex）**：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。
- **边（Edge）**：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：$e = \langle u, v \rangle$，表示从 $u$ 到 $v$ 的一条边，其中 $u$ 称为起始点，$v$ 称为终止点。

![](https://qcdn.itcharge.cn/images/20220307145142.png)

- **子图（Sub Graph）**：对于图 $G = (V, E)$ 与 $G^{'} = (V^{'}, E^{'})$，如果存在 $V^{'} \subseteq V$，$E^{'} \subseteq E$，则称图 $G^{'}$ 是图 $G$ 的一个子图。在下面的示意图中我们给出了一个图 $G$ 及其一个子图 $G^{'}$。特别的，根据定义，$G$ 也是其自身的子图。

![](https://qcdn.itcharge.cn/images/20220308144554.png)

## 2. 图的分类

### 2.1 无向图和有向图

按照边是否有方向，我们可以将图分为两种类型：**「无向图」** 和 **「有向图」**。

- **无向图（Undirected Graph）**：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。
- **有向图（Directed Graph）**：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。

在无向图中，每条边都是由两个顶点组成的无序对。例如下图左侧中的顶点 $v_1$ 和顶点 $v_2$ 之间的边记为 $(v_1, v_2)$ 或 $(v_2, v_1)$。

在有向图中，有向边也被称为弧，每条弧是由两个顶点组成的有序对，例如下图右侧中从顶点 $v_1$ 到顶点 $v_2$ 的弧，记为 $\langle v_1, v_2 \rangle$，$v_1$ 被称为弧尾，$v_2$ 被称为弧头，如下图所示。

![](https://qcdn.itcharge.cn/images/20220307160017.png)

如果无向图中有 $n$ 个顶点，则无向图中最多有 $n * (n - 1) / 2$ 条边。而具有 $n * (n - 1) / 2$ 条边的无向图称为 **「完全无向图（Completed Undirected Graph）」**。

如果有向图中有 $n$ 个顶点，则有向图中最多有 $n * (n - 1)$ 条弧。而具有 $n * (n - 1)$ 条弧的有向图称为 **「完全有向图（Completed Directed Graph）」**。

如下图所示，左侧为包含 `4` 个顶点的完全无向图，右侧为包含 `4` 个顶点的完全有向图。

![](https://qcdn.itcharge.cn/images/20220308151436.png)

下面介绍一下无向图和有向图中一个重要概念 **「顶点的度」**。

- **顶点的度**：与该顶点 $v_i$ 相关联的边的条数，记为 $TD(v_i)$。

例如上图左侧的完全无向图中，顶点 $v_3$ 的度为 `3`。

而对于有向图，我们可以将顶点的度分为 **「顶点的出度」** 和 **「顶点的入度」**。

- **顶点的出度**：以该顶点 $v_i$ 为出发点的边的条数，记为 $OD(v_i)$。
- **顶点的入度**：以该顶点 $v_i$ 为终止点的边的条数，记为 $ID(v_i)$。
- 有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 $TD(v_i) = OD(v_i) + ID(v_i)$。

例如上图右侧的完全有向图中，顶点 $v_3$ 的出度为 `3`，入度为 `3`，顶点 $v_3$ 的度为 `3 + 3 = 6`。

### 2.2 环形图和无环图

 **「路径」** 是图中的一个重要概念，对于图 $G = (V, E)$，如果存在顶点序列 $v_{i_0}, v_{i_1}, v_{i_2},… , v_{i_m}$，使得 $(v_{i_0}, v_{i_1})，(v_{i_1}, v_{i_2})，…，(v_{i_{m-1}}, v_{i_m}) \in E$（即他们都是图 G 的边，对于有向图则是 $\langle v_{i_0}, v_{i_1} \rangle，\langle v_{i_1}, v_{i_2} \rangle，…，\langle v_{i_{m-1}}, v_{i_m} \rangle \in E$），则称该顶点序列为顶点 $v_{i_0}$ 和顶点 $v_{i_m}$ 之间的一条路径，其中 $v_{i_0}$ 是这条路径的起始点，$v_{i_m}$ 是这条路径的终止点。

简单来说，如果顶点 $v_{i_0}$ 可以通过一系列的顶点和边，到达顶点 $v_{i_m}$，则称顶点 $v_{i_0}$ 和顶点 $v_{i_m}$ 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。

- **环（Circle）**：如果一条路径的起始点和终止点相同（即 $v_{i_0} = v_{i_m}$），则称这条路径为 **「回路」** 或者 **「环」**。

- **简单路径**：顶点序列中顶点不重复出现的路径称为 **简单路径**。

而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。

- **环形图（Circular Graph）**：如果图中存在至少一条环路，则该图称为环形图。
- **无环图（Acyclic Graph）**：如果图中不存在环路，则该图称为无环图。

特别的，在有向图中，如果不存在环路，则将该图称为 **「有向无环图（Directed Acyclic Graph）」**。因为有向无环图拥有为独特的拓扑结构，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景。

### 2.3 连通图和非连通图

#### 2.3.1 连通无向图和连通分量

在无向图中，如果从顶点 $v_i$ 到顶点 $v_j$ 有路径，则称顶点 $v_i$ 和 $v_j$ 是连通的。

- **连通无向图**：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。
- **非连通无向图**：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。

如下图所示，左侧图中 $v_1$ 与 $v_2$、$v_3$、$v_4$、$v_5$、$v_6$ 都是连通的，所以该图为连通无向图。右侧图中 $v_1$ 与 $v_2$、$v_3$、$v_4$ 都是连通的，但是 $v_1$ 和 $v_5$、$v_6$ 之间不存在任何路径，则该图为非连通无向图。

![](https://qcdn.itcharge.cn/images/20220308152148.png)

下面介绍一下无向图的 **「连通分量」** 概念。有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的 **连通分量**。

- **连通子图**：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。
- **连通分量**：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。
- **极⼤连通⼦图**：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。

例如上图中右侧的非连通无向图，其本身是不连通的。但顶点 $v_1$、$v_2$、$v_3$、$v_4$ 与其相连的边构成的子图是连通的，并且不存在包含它的更大的连通子图了，所以该子图是原图的一个连通分量。同理，顶点 $v_5$、$v_6$ 与其相连的边构成的子图也是原图的一个连通分量。

#### 2.3.2 强连通有向图和强连通分量

在有向图中，如果从顶点 $v_i$ 到 $v_j$ 有路径，并且从顶点 $v_j$ 到 $v_i$ 也有路径，则称顶点 $v_i$ 与 $v_j$ 是连通的。

- **强连通有向图**：如果图中任意两个顶点 $v_i$ 和 $v_j$，从 $v_i$ 到 $v_j$ 和从 $v_j$ 到 $v_i$ 都有路径，则称该图为强连通有向图。
- **非强连通图**：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通图。

与无向图类似，有向图的一个极大强连通子图称为该图的 **强连通分量**。

- **强连通子图**：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。
- **强连通分量**：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。
- **极⼤强连通⼦图**：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。

### 2.4 带权图

有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 **权**。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。

- **带权图**：如果图的每条边都被赋以⼀个权值，这种图称为带权图。
- **网络**：带权的连通⽆向图称为⽹络。

### 2.5 稠密图和稀疏图

根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。

- **稠密图（Dense Graph）**：有很多条边或弧（边的条数 e 远小于完全图的边数，如 $e < nlog_2n$）的图称为稠密图。
- **稀疏图（Sparse Graph）**：有很少条边或弧（边的条数 e 接近于完全图的边数）的图称为稀疏图。

## 3. 图的存储结构

图的结构比较复杂，我们需要表示顶点和边。一个图可能有任意多个（有限个）顶点，而且任何两个顶点之间都可能存在边。我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。

图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。

接下来我们来介绍几个常用的图的存储结构。在下文中，我们约定用 $n$ 代表顶点数目，$m$ 代表边数目，$TD(v_i)$ 表示顶点 $v_i$ 的度。

### 3.1 邻接矩阵

#### 3.1.1 邻接矩阵的原理描述

> **邻接矩阵（Adjacency Matrix）**：使用一个二维数组 `adj_matrix` 来存储顶点之间的邻接关系。
>
> - 对于无权图来说，如果 `adj_matrix[i][j]` 为 `1`，则说明顶点 $v_i$ 到 $v_j$ 存在边，如果 `adj_matrix[i][j]` 为 `0`，则说明顶点 $v_i$ 到 $v_j$ 不存在边。
> - 对于带权图来说，如果 `adj_matrix[i][j]` 为 `w`，并且 `w != float('inf')`，则说明顶点 $v_i$ 到 $v_j$ 的权值为 `w`。如果 `adj_matrix[i][j]` 为 `float('inf')` ，则说明顶点 $v_i$ 到 $v_j$ 不存在边。

邻接矩阵的特点：

- 优点：实现简单，并且可以直接查询顶点 $v_i$ 与 $v_j$ 之间是否有边存在，还可以直接查询边的权值。
- 缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 $n > 10^5$）时，使用邻接矩阵建立一个 `n * n` 的二维数组不太现实。

#### 3.1.2 邻接矩阵的算法分析

邻接矩阵的时间复杂度：

- 图的初始化和创建操作：$O(n^2)$。
- 查询是否存在某条边：$O(1)$。
- 遍历某个点的所有边：$O(n)$。
- 遍历整张图：$O(n^2)$。

邻接矩阵的空间复杂度：

- 空间复杂度：$O(n^2)$。

#### 3.1.3 邻接矩阵的代码实现

```Python
class Graph:                                    # 基本图类，采用邻接矩阵表示
    # 图的初始化操作，vertices 为顶点
    def __init__(self, ver_count):
        self.ver_count = ver_count              # 顶点个数
        self.adj_matrix = [[None for _ in range(ver_count)] for _ in range(ver_count)]  # 邻接矩阵
    
    # 判断顶点 v 是否有效
    def __valid(self, v):
        return 0 <= v <= self.ver_count
    
    # 图的创建操作，edges 为边信息
    def creatGraph(self, edges=[]):
        for vi, vj, val in edges:
            self.add_edge(vi, vj, val)
    
    # 向图的邻接矩阵中添加边：vi - vj，权值为 val
    def add_edge(self, vi, vj, val):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")
        
        self.adj_matrix[vi][vj] = val
    
    # 获取 vi - vj 边的权值
    def get_edge(self, vi, vj):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")

        return self.adj_matrix[vi][vj]
    
    # 根据邻接矩阵打印图的边
    def printGraph(self):
        for vi in range(self.ver_count):
            for vj in range(self.ver_count):
                val = self.get_edge(vi, vj)
                if val:
                    print(str(vi) + ' - ' + str(vj) + ' : ' + str(val))
    

graph = Graph(6)
edges = [[1, 4, 3],[1, 3, 9],[3, 4, 6],[2, 5, 4],[4, 5, 2]]
graph.creatGraph(edges)
print(graph.get_edge(3, 4))
graph.printGraph()
```

### 3.2 边集数组

#### 3.2.1 边集数组的原理描述

> **边集数组（Edgeset Array）**：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 `vi`、终点 `vj` 和边的权值 `val`（如果是带权图）。

#### 3.2.2 边集数组的算法分析

边集数组的时间复杂度：

- 图的初始化和创建操作：$O(m)$。
- 查询是否存在某条边：$O(m)$。
- 遍历某个点的所有边：$O(m)$。
- 遍历整张图：$O(nm)$。

边集数组的空间复杂度：

- 空间复杂度：$O(m)$。

采用边集数组计算节点的度或者查找某条边时，需要遍历整个边集数组，时间复杂度为 $O(m)$，`m` 是边的数量。除非特殊必要，很少用使用边集数组来存储图。

一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。

#### 3.2.3 边集数组的代码实现

```Python
class EdgeNode:                                 # 边信息类
    def __init__(self, vi, vj, val):
        self.vi = vi                            # 边的起点
        self.vj = vj                            # 边的终点
        self.val = val                          # 边的权值
        
class Graph:                                    # 基本图类，采用边集数组表示
    def __init__(self):
        self.edges = []							# 边数组
        
    # 图的创建操作，edges 为边信息
    def creatGraph(self, edges=[]):
        for vi, vj, val in edges:
            self.add_edge(vi, vj, val)
            
    # 向图的边数组中添加边：vi - vj，权值为 val
    def add_edge(self, vi, vj, val):
        edge = EdgeNode(vi, vj, val)            # 创建边节点
        self.edges.append(edge)                 # 将边节点添加到边数组中
        
    # 获取 vi - vj 边的权值
    def get_edge(self, vi, vj):
        for edge in self.edges:
            if vi == edge.vi and vj == edge.vj:
                val = edge.val
                return val
        return None
    
    # 根据边数组打印图
    def printGraph(self):
        for edge in self.edges:
            print(str(edge.vi) + ' - ' + str(edge.vj) + ' : ' + str(edge.val))
            
graph = Graph()
edges = [[1, 4, 3],[1, 3, 9],[3, 4, 6],[2, 5, 4],[4, 5, 2]]
graph.creatGraph(edges)
print(graph.get_edge(3, 4))
graph.printGraph()
```

### 3.3 邻接表

#### 3.3.1 邻接表的原理描述

> **邻接表（Adjacency List）**：使用顺序存储和链式存储相结合的存储结构来存储图的顶点和边。其数据结构包括两个部分，其中一个部分是数组，主要用来存放顶点的数据信息，另一个部分是链表，用来存放边信息。

在邻接表的存储方法中，对于对图中每个顶点 $v_i$ 建立一个线性链表，把所有邻接于 $v_i$ 的顶点链接到单链表上。这样对于具有 `n` 个顶点的图而言，其邻接表结构由 `n` 个线性链表组成。

然后我们在每个顶点前边设置一个表头节点，称之为「顶点节点」。每个顶点节点由「顶点域」和「指针域」组成。其中顶点域用于存放某个顶点的数据信息，指针域用于指出该顶点第 `1` 条边所对应的链节点。

为了方便随机访问任意顶点的链表，通常我们会使用一组顺序存储结构（数组）存储所有「顶点节点」部分，顺序存储结构（数组）的下标表示该顶点在图中的位置。

一个无向图及其邻接表如下图所示。



一个有向图及其邻接表如下图所示。

#### 3.3.2 邻接表的算法分析

邻接表的时间复杂度：

- 图的初始化和创建操作：$O(n + m)$。
- 查询是否存在 $v_i$ 到 $v_j$ 的边：$O(TD(v_i))$。
- 遍历某个点的所有边：$O(TD(v_i))$。
- 遍历整张图：$O(n + m)$。

邻接表的空间复杂度：

- 空间复杂度：$O(m)$。

#### 3.3.2 邻接表的代码实现

```Python
class EdgeNode:                                 # 边信息类
    def __init__(self, vj, val):
        self.vj = vj                            # 边的终点
        self.val = val                          # 边的权值
        self.next = None                        # 下一条边

class VertexNode:                               # 顶点信息类
    def __init__(self, vi):
        self.vi = vi                            # 边的起点
        self.head = None                        # 下一个邻接点
        
class Graph:
    def __init__(self, ver_count):
        self.ver_count = ver_count
        self.vertexs = []
        for vi in range(ver_count):
            vertex = VertexNode(vi)
            self.vertexs.append(vertex)
    
    # 判断顶点 v 是否有效
    def __valid(self, v):
        return 0 <= v <= self.ver_count
    
    def creatGraph(self, edges=[]):
        for vi, vj, val in edges:
            self.add_edge(vi, vj, val)
    
    # 向图的邻接表中添加边：vi - vj，权值为 val
    def add_edge(self, vi, vj, val):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")
            
        vertex = self.vertexs[vi]
        edge = EdgeNode(vj, val)
        edge.next = vertex.head
        vertex.head = edge


    # 获取 vi - vj 边的权值
    def get_edge(self, vi, vj):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")
        
        vertex = self.vertexs[vi]
        cur_edge = vertex.head
        while cur_edge:
            if cur_edge.vj == vj:
                return cur_edge.val
            cur_edge = cur_edge.next
        return None
        
    # 根据邻接表打印图的边
    def printGraph(self):
        for vertex in self.vertexs:
            cur_edge = vertex.head
            while cur_edge:
                print(str(vertex.vi) + ' - ' + str(cur_edge.vj) + ' : ' + str(cur_edge.val))
                cur_edge = cur_edge.next
```

### 3.4 链式前向星

#### 3.4.1 链式前向星的原理描述

> **链式前向星（Linked Forward Star）**：也叫做静态邻接表，实质上就是使用静态链表实现的邻接表。链式前向星将边集数组和邻接表相结合，可以快速访问一个节点所有的邻接点，并且使用很少的额外空间。

链式前向星采用了一种静态链表的存储方式，可以说是目前建图和遍历效率最高的存储方式。

链式前向星由两种数据结构组成：

- **特殊的边集数组**：`edges`，其中 `edges[i]` 表示第 `i` 条边。`edges[i].vj` 表示第 `i` 条边的终止点，`edges[i].val` 表示第 `i` 条边的权值，`edges[i].next` 表示与第 `i` 条边同起始点的下一条边的存储位置。
- **头节点数组**：`head`，其中 `head[i]` 存储以顶点 `i` 为起始点的第 `1` 条边在数组 `edges` 中的下标。

链式前向星其实并没有改变边集数组原来的存储数学，只是利用 `head` 数组构成静态链表，建立了顶点 $v_i$ 和顶点 $v_i$ 所连第 `1` 条边的关系。

#### 3.4.2 链式前向星的算法分析

链式前向星的时间复杂度：

- 图的初始化和创建操作：$O(n + m)$。
- 查询是否存在 $v_i$ 到 $v_j$ 的边：$O(TD(v_i))$。
- 遍历某个点的所有边：$O(TD(v_i))$。
- 遍历整张图：$O(n + m)$。

链式前向星的空间复杂度：

- 空间复杂度：$O(n + m)$。

#### 3.4.3 链式前向星的代码实现

```Python
class EdgeNode:                                 # 边信息类
    def __init__(self, vj, val):
        self.vj = vj                            # 边的终点
        self.val = val                          # 边的权值
        self.next = None                        # 下一条边
        
class Graph:
    def __init__(self, ver_count, edge_count):
        self.ver_count = ver_count              # 顶点个数
        self.edge_count = edge_count            # 边个数
        self.head = [-1 for _ in range(ver_count)]  # 头节点数组
        self.edges = []                         # 边集数组
    
    # 判断顶点 v 是否有效
    def __valid(self, v):
        return 0 <= v <= self.ver_count
    
    # 图的创建操作，edges 为边信息
    def creatGraph(self, edges=[]):
        for i in range(len(edges)):
            vi, vj, val = edges[i]
            self.add_edge(i, vi, vj, val)
            
    # 向图的边集数组中添加边：vi - vj，权值为 val
    def add_edge(self, index, vi, vj, val):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")
            
        edge = EdgeNode(vj, val)                # 构造边节点
        edge.next = self.head[vi]               # 边节点的 next 指向原来首指针
        self.edges.append(edge)                 # 边集数组添加该边
        self.head[vi] = index                   # 首指针指向新加边所在边集数组的下标
    
    # 获取 vi - vj 边的权值
    def get_edge(self, vi, vj):
        if not self.__valid(vi) or not self.__valid(vj):
            raise ValueError(str(vi) + ' or ' + str(vj) + " is not a valid vertex.")
            
        index = self.head[vi]                   # 得到顶点 vi 相连的第一条边在边集数组的下标
        while index != -1:                      # index == -1 时说明 vi 相连的边遍历完了
            if vj == self.edges[index].vj:      # 找到了 vi - vj 边
                return self.edges[index].val    # 返回 vi - vj 边的权值
            index = self.edges[index].next      # 取顶点 vi 相连的下一条边在边集数组的下标
        return None                             # 没有找到 vi - vj 边
    
    # 根据链式前向星打印图的边
    def printGraph(self):
        for vi in range(self.ver_count):        # 遍历顶点 vi
            index = self.head[vi]               # 得到顶点 vi 相连的第一条边在边集数组的下标
            while index != -1:                  # index == -1 时说明 vi 相连的边遍历完了
                print(str(vi) + ' - ' + str(self.edges[index].vj) + ' : ' + str(self.edges[index].val))
                index = self.edges[index].next  # 取顶点 vi 相连的下一条边在边集数组的下标
                
graph = Graph(6, 5)
edges = [[1, 4, 3],[1, 3, 9],[3, 4, 6],[2, 5, 4],[4, 5, 2]]
graph.creatGraph(edges)
print(graph.get_edge(3, 4))
graph.printGraph()
```

## 4. 图论问题应用

图论和图论算法在计算机科学中扮演这很重要的角色，它提供了对很多问题都有效的一种简单而系统的建模方式。很多实际问题都可以转化为图论问题，然后使用图论的景点算法加以解决。例如：

- 集成电路的设计和布线。
- 互联网和路由移动电话网的路由设计。

常见的图论问题应用大概可以分为以下几类：**图的遍历问题**、**图的连通性问题**、**图的生成树问题**、**图的最短路径问题** 等等。

### 4.1 图的遍历问题

> **图的遍历**：与树的遍历类似，图的遍历指的是从图的某一个顶点出发，按照某种搜索方式对图中的所有节点都仅访问一次。

图的遍历是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

根据搜索方式的不同，可以将图的遍历分为「深度优先搜索」和「广度优先搜索」。

- **深度优先搜索**：从某一顶点出发，沿着⼀条路径⼀直搜索下去，在⽆法搜索时，回退到刚刚访问过的节点。
- **广度优先搜索**：从某个顶点出发，⼀次性访问所有未被访问的邻接点，再依次从这些已访问过的邻接点出发，⼀层⼀层地访问。

### 4.2 图的连通性问题

我们在「2.3 连通图和非连通图」中提到过「2.3.1 连通无向图和连通分量」和「2.3.2 强连通有向图和强连通分量」。

在无向图中，图的连通性问题主要包括：**求无向图的连通分量**、**求点双连通分量（找割点）**、**求边双连通分量（找桥）**、**全局最小割问题** 等等。

在有向图中，图的连通性问题主要包括：**求有向图的强连通分量**、**最小点基**、**最小权点基**、**2-SAT 问题** 等等。

### 4.3 图的生成树问题

> **图的生成树（Spanning Tree）**：如果连通图 G 的一个子图是一棵包含图 G 所有顶点的树，则称该子图为 G 的生成树。生成树是连通图的包含图中的所有顶点的极小连通子图。图的生成树不惟一。从不同的顶点出发进行遍历，可以得到不同的生成树。

图的生成树问题主要包括：**最小生成树问题**、**次小生成树问题** 和 **有向图的最小树形图问题** 等等。

- **无向图的最小生成树**：如果连通图 $G$ 是一个带权无向图，则生成树的边也带权，则称该带权图中所有带权生成树中权值总和最小的生成树为最小生成树（也称为最小代价生成树）。
- **无向图的次小生成树**：如果连通图 $G$ 是一个带权无向图，生成树 $T$ 是图 $G$ 的一个最小生成树，如果有另一棵生成树 $T_1$，$T_1 \ne T$，满足不存在树 $T^{'}$，$T^{'} \ne T$，且 $w(T^{'}) < W(T_1)$，则称 $T_1$ 是图 $G$ 的次小生成树。 
- **有向图的最小树形图**：如果连通图 $G$ 是一个带权有向图，以顶点 $v_i$ 为根节点的生成树 $T$ 中，顶点 $v_i$ 到任意非 $v_i$ 顶点的路径存在且唯一，并且生成树 $T$ 中权值总和最小，则该生成树被称为有向图 $G$ 的最小树形图。

### 4.4 图的最短路径问题

> **图的最短路径问题**：如果用带权图来表示真实的交通、物流或社交网络，则边的权重可能代表交通运输费、距离或者熟悉程度。此时我们会考虑两个不同顶点之间的最短路径有多长，这一类问题统称为最短路径。并且我们称路径上的第一个顶点为源点，最后一个顶点为终点。

按照源点数目的不同，可以将图的最短路径问题分为 **单源最短路径问题** 和 **多源最短路径问题**。

- **单源最短路径问题**：从一个顶点出发到图中其余各个顶点之间的最短路径问题。
- **多源最短路径问题**：图中任意两点之间的最短路径问题。

**单元最短路径问题** 的求解还是 **差分约束系统问题** 的基础。

除此之外，在实际应用中，有时候除了需要知道最短路径外，还需要知道次最短路径或者第三最短路径。这样的多条最短路径问题称为 **`k` 最短路径问题**。

## 参考资料

- 【书籍】ACM-ICPC 程序设计系列 - 图论及应用 \- 陈宇 吴昊 主编
- 【书籍】数据结构教程 第 3 版 - 唐发根 著
- 【书籍】大话数据结构 - 程杰 著
- 【书籍】算法训练营 - 陈小玉 著
- 【博文】[图的基础知识 | 小浩算法](https://www.geekxh.com/1.99.其他补充题目/50.html)
- 【博文】[链式前向星及其简单应用 | Malash's Blog](https://malash.me/200910/linked-forward-star/)
