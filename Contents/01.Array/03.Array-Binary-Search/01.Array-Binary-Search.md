## 1. 算法介绍

> **「二分查找算法（Binary Search Algorithm）」**，也叫做 **「折半查找算法」**、**「对数查找算法」**。是一种在有序数组中查找某一特定元素的搜索算法。
>
> 基本算法思想：先确定待查找元素所在的区间范围，在逐步缩小范围，直到找到元素或找不到该元素为止。

二分查找算法的过程如下所示：

- 每次查找时从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
- 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。
- 如果在某一步骤数组为空，则代表找不到。

举个例子来说，给定一个有序数组 `[2, 3, 5, 6, 8]`。如果我们希望查找 `6` 是否在这个数组中。

- 第一次区间为整个数组 `[2, 3, 5, 6, 8]`，中位数是 `5`，因为 `5` 小于 `6`，所以如果 `6` 存在在这个数组中，那么 `6` 一定在 `5` 右边的这一半中。于是我们的查找范围变成了 `[5, 6, 8]`。
- 第二次区间为 `[5, 6, 8]`，中位数是 `6`，正好是我们需要查找的数字。

于是我们发现，对于一个长度为 `5` 的有序数组，我们只进行了 `2` 次查找就找到了我们需要查找的数字。而如果是依次遍历数组，则最坏情况下，我们需要查找 `5` 次。

## 2. 算法思想

二分查找算法是经典的 **「减而治之」** 的思想。

这里的 **「减」** 是减少问题规模的意思，**「治」** 是解决问题的意思。**「减」** 和 **「治」** 结合起来的意思就是 **「排除法解决问题」**。即：每一次查找，排除掉一定不存在目标元素的区间，在剩下可能存在目标元素的区间中继续查找。每一次通过一些条件判断，将待搜索的区间逐渐缩小，以达到「减少问题规模」的目的。而于问题的规模是有限的，经过有限次的查找，最终会查找到目标元素或者查找失败。

## 3. 简单二分查找

下面通过一个简单的例子来讲解下二分查找的思路和代码。

- 题目链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

### 2.1 题目大意

给定一个升序的数组 `nums`，和一个目标值 `target`，返回 `target` 在数组中的位置，如果找不到，则返回 `-1`。

### 2.2 解题思路

利用二分查找算法进行解题。

设定左右节点为数组两端，即 `left = 0`，`right = len(nums) - 1`，代表待查找区间为 `[left, right]`（左闭右闭）。

取两个节点中心位置 `mid`，比较中心位置值 `nums[mid]` 与目标值 `target` 的大小。

- 如果中心位置值 `nums[mid]` 与目标值 `target` 相等，则返回中心位置。
- 如果中心位置值 `nums[mid]` 小于目标值 `target`，则将左节点设置为 `mid + 1`，然后继续在右区间 `[mid + 1, right]` 搜索。
- 如果中心位置值 `nums[mid]` 大于目标值 `target`，则将右节点设置为 `mid - 1`，然后继续在左区间 `[left, mid - 1]` 搜索。

```Python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        # 在区间 [left, right] 内查找 target
        while left <= right:
            # 取区间中间节点
            mid = (left + right) // 2
            # 如果找到目标值，则直接范围中心位置
            if nums[mid] == target:
                return mid
            # 如果 nums[mid] 小于目标值，则在 [mid + 1, right] 中继续搜索
            elif nums[mid] < target:
                left = mid + 1
            # 如果 nums[mid] 大于目标值，则在 [left, mid - 1] 中继续搜索
            else:
                right = mid - 1
        # 未搜索到元素，返回 -1
        return -1
```

## 4. 二分查找细节

从上面的例子中我们了解了二分查找的思路和具体代码。但是真正在解决二分查找题目的时候还是需要考虑很多细节的。比如说以下几个问题：

1. 区间应该是左闭右闭，还是左闭右开？
2. `mid = (left + right) // 2`，还是 `mid = (left + right + 1) // 2`？
3. `left < right`，还是 `left <= right`？
4. `left = mid + 1`、`right = mid - 1`，还是 `left = mid `、`right = mid`？

下面一一讲解。

### 4.1 区间的开闭

区间的左闭右闭、左闭右开指的是初始待查找区间的范围。

- 左闭右闭：初始化赋值时，`left = 0`，`right = len(nums) - 1`，`left` 为数组第一个元素位置，`right` 为数组最后一个元素位置，从而区间 `[left, right]` 左右边界上的点都能取到。
- 左闭右开：初始化赋值时，`left = 0`，`right = len(nums)`，`left` 为数组第一个元素位置，`right` 为数组最后一个元素的下一个位置，从而区间 `[left, right)` 左边界点能取到，而右边界上的点不能取到。

关于左闭右闭、左闭右开，其实在网上都有对应的代码和解法。但是相对来说，左闭右开这种写法在解决问题的过程中，需要考虑的情况更加复杂，所以建议 **全部使用「左闭右闭」区间**。

### 4.2 `mid` 的取值问题

在二分查找的实际问题中，最常见的 `mid` 取值就是 `mid = (left + right) // 2` 或者 `mid = left + (right - left) // 2 `。前者是最常见写法，后者是为了防止整型溢出。式子中 `// 2` 就代表的含义是中间数「向下取整」。当待查找区间中有偶数个元素个数时，则位于最中间的数为 `2` 个，这时候使用上面式子只能取到中间靠左边那个数，而取不到中间靠右边的那个数。那么，右边的那个数到底能取吗？

其实，右边的数也是可以取的，令 `mid = (left + right + 1) // 2`，或者 `mid = left + (right - left + 1) // 2`。这样如果待查找区间的元素为偶数个，就能取到中间靠右边的那个数了，把这个式子代入到 [704. 二分查找](https://leetcode-cn.com/problems/binary-search/) 中试一试，发现也是能通过题目评测的。

这是因为二分查找的思路是根据每次选择中间位置上的数值来决定下一次在哪个区间查找元素。每一次选择的元素位置可以是中间位置，但并不是一定非得是区间中间位置元素，靠左一些、靠右一些、甚至区间三分之一、五分之三处等等，都是可以的。比如说 `mid = (left + right) * 3 // 5` 也是可以的。

但一般来说，取中间位置元素在平均意义下所达到的效果最好。同时这样写最简单。而对于 `mid` 值是向下取整还是向上取整，大多数时候是选择不加 `1`。但有些题目下，是需要考虑加 `1` 的，这要中具体题目中进行考虑。

### 4.3 出界条件的判断

我们经常看到二分查找算法的写法中，`while` 语句出界判断的语句有`left < right` 和 `left <= right` 两种写法。那我们究竟应该在什么情况用什么写法呢？

- 如果判断语句为`left < right`，则出界条件是 `left == right`，

### 4.4 搜索区间范围的选择



## 参考资料

- 【博文】[Learning-Algorithms-with-Leetcode - 第 3.1 节 二分查找算法](https://www.yuque.com/liweiwei1419/algo/wkmtx4)
- 【博文】[二分法的细节加细节 你真的应该搞懂！！！_小马的博客](https://blog.csdn.net/xiao_jj_jj/article/details/106018702)
- 【课程】[零起步学算法 - LeetBook - 二分查找的基本思想：减而治之](https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/)

