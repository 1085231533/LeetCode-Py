## 1. 单调栈简介

> **单调栈（Monotone Stack）**：一种特殊的栈。在栈的「先进后出」规则基础上，要求「从 **栈顶** 到 **栈底** 的元素是单调递增（或者单调递减）」。其中满足从栈顶到栈底的元素是单调递增的栈，叫做「单调递增栈」。满足从栈顶到栈底的元素是单调递减的栈，叫做「单调递减栈」。

注意：这里定义的顺序是从「栈顶」到「栈底」。有的文章里是反过来的，本文以「栈顶」到「栈底」的顺序为基准。

单调栈的进栈过程如下：

- **单调递增栈**：只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。这样就保证了栈顶元素是栈中最小的元素，从栈顶到栈底的元素值是单调递增的。具体过程如下：
  - 假设当前进栈元素为 `x`，如果栈顶元素大于 `x`，则直接入栈。
  - 否则从栈顶开始遍历栈中元素，把小于 `x` 或者等于 `x` 的元素弹出栈，直到遇到一个大于 `x` 的元素为止，然后再把 `x` 压入栈中。
- **单调递减栈**：只有比栈顶元素大的元素才能直接进栈，否则需要先将栈中比当前元素大的元素出栈，再将当前元素入栈。这样就保证了栈顶元素是栈中最大的元素，从栈顶到栈底的元素值是单调递减的。具体过程如下：
  - 假设当前进栈元素为 `x`，如果栈顶元素大于 `x`，则直接入栈。
  - 否则从栈顶开始遍历栈中元素，把大于 `x` 或者等于 `x` 的元素弹出栈，直到遇到一个小于 `x` 的元素为止，然后再把 `x` 压入栈中。

下面我们以一个「单调递增栈」为例，模拟一下进栈、出栈过程。

数组元素为：`[4, 3, 2, 5, 7, 4, 6, 8]`。

具体过程如下：

| 第 i 步 | 操 作                  | 结 果（左侧为栈底） |
| :-----: | ---------------------- | ------------------- |
|    1    | 4 入栈                 | [4]                 |
|    2    | 4 出栈，3 入栈         | [3]                 |
|    3    | 3 出栈，2 入栈         | [2]                 |
|    4    | 5 入栈                 | [2, 5]              |
|    5    | 7 入栈                 | [2, 5, 7]           |
|    6    | 7 出栈，5 出栈，4 入栈 | [2, 4]              |
|    7    | 6 入栈                 | [2, 4, 6]           |
|    8    | 8 入栈                 | [2, 4, 6, 8]        |

以上述过程第 6 步为例，所对应的图示过程为：



当栈中元素为 

## 2. 单调栈适用场景

## 3. 单调栈模板

### 3.1 单调递增栈模板

```Python
def monotoneIncreasingStack(nums):
	stack = []
	for num in nums:
		while stack and num <= stack[-1]:
			stack.pop()
		stack.append(num)
```

### 3.2 单调递减栈模板

```Python
def monotoneDecreasingStack(nums):
	stack = []
	for num in nums:
		while stack and num >= stack[-1]:
			stack.pop()
		stack.append(num)
```

## 3. 单调栈应用

### 3.1 下一个更大元素 I

#### 3.1.1 题目链接

-  [0496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

#### 3.1.2 题目大意

给定两个没有重复元素的数组 `nums1` 和 `nums2` ，其中 `nums1` 是 `nums2` 的子集。

要求：找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。

- `nums1` 中数字 `x` 的下一个更大元素是指： `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素。如果不存在，对应位置输出 `-1`。

#### 3.1.3 解题思路

第一种思路是根据题意直接暴力求解。

第二种思路是使用单调栈。

- 使用数组 `res` 存放答案。使用哈希表 `num_map` 用于存储 `nums2` 中下一个比当前元素大的数值，映射关系为 `当前元素值：下一个比当前元素大的数值`。
- 遍历数组 `nums2`，对于当前元素：
  - 如果当前元素值较小，则直接让当前元素值入栈。
  - 如果当前元素值较大，则一直出栈，直到当前元素值小于栈顶元素。
    - 出栈时，出栈元素是第一个大于当前元素值的元素。则将其映射到 `num_map` 中。

- 遍历完数组 `nums2`，建立好所有元素下一个更大元素的映射关系之后，再遍历数组 `nums1`。
- 从 `num_map` 中取出对应的值，加入到答案数组中。
- 最终输出答案数组 `res`。

## 代码

```Python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        stack = []
        num_map = dict()
        for num in nums2:
            while stack and num > stack[-1]:
                num_map[stack[-1]] = num
                stack.pop()
            stack.append(num)

        for num in nums1:
            res.append(num_map.get(num, -1))
        return res
```

## 参考资料

- 【博文】[动画：什么是单调栈？_- 吴师兄学编程](https://www.cxyxiaowu.com/450.html)
- 【博文】[单调栈 - OI Wiki](https://oi-wiki.org/ds/monotonous-stack/)
- 【博文】[单调栈解题模板秒杀八道题 - lucifer 的网络博客](https://lucifer.ren/blog/2020/11/03/monotone-stack/)