# [0118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

- 标签：数组
- 难度：简单

## 题目大意

**描述**：给定一个整数 `n`。

**要求**：生成前 `n` 行的杨辉三角。

**说明**：

- $1 \le numRows \le 30$。

**示例**：

```Python
输入    numRows = 5
输出    [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

![](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

## 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照行数进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 为：杨辉三角第 `i` 行、第 `j` 列位置上的值。

###### 3. 状态转移方程

根据观察，很容易得出状态转移方程为：`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`，此时 `i > 0，j > 0`。

###### 4. 初始条件

- 每一行第一列都为 `1`，即 `dp[i][0] = 1`。
- 每一行最后一列都为 `1`，即 `dp[i][i] = 1`。

###### 5. 最终结果

根据题意和状态定义，我们将每行结果存入答案数组中，将其返回。

### 思路 1：动态规划代码

```Python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        dp = [[0] * i for i in range(1, numRows + 1)]
        
        for i in range(numRows):
            dp[i][0] = 1
            dp[i][i] = 1

        res = []
        for i in range(numRows):
            for j in range(i):
                if i != 0 and j != 0:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
            res.append(dp[i])

        return res
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。初始条件赋值的时间复杂度为 $O(n)$，两重循环遍历的时间复杂度为 $O(n^2)$，所以总的时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n^2)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(n^2)$。

## 代码

```Python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ans = list()
        for i in range(numRows):
            row = list()
            for j in range(i+1):
                if j == 0 or j == i:
                    row.append(1)
                else:
                    row.append(ans[i-1][j-1]+ans[i-1][j])
            ans.append(row)
        return ans
```

