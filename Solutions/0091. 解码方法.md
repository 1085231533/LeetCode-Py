## [0091. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

- 标签：字符串、动态规划
- 难度：中等

## 题目大意

给定一个数字字符串 s，按照要求映射为 26 个字母，求解共有多少种可能的翻译方案。

## 解题思路

可用动态规划来做。设 dp[i] 表示字符串 s 前 i 个字符 s[0: i] 的翻译方案数。dp[i] 的来源有两种情况：

1. 对 s[i] 进行翻译。那么只要 s[i] != 0，就可以被翻译为 A~I 的某个字母，此时方案数为 dp[i] = dp[i-1]
2. 对 s[i-1] 和 s[i] 进行翻译，s[i-1] != 0，且 s[i-1] 和 s[i] 组成的整数必须小于等于 26 才能翻译，这样才能翻译为 J~Z 中的某字母，此时方案数为 dp[i] = dp[i-2]。

这两种情况有可能是同时存在的，也有可能都不存在。在进行转移的时候，将符合要求的方案数累加起来即可。

状态转移方程可以写为：

$dp[i] += \left\{  \begin{array} \ dp[i-1] & s[i] \ne 0 \\ dp[i-2] & s[i-1] \ne 0，s[i-1:i] \le 26 \end{array}\right.$

现在考虑初始边界条件。字符串为空时，只有一个翻译方案，翻译为空字符串，即 dp[0] = 0。

字符串只有一个字符时，需要考虑该字符是否为 0，不为 0 的话，dp[1] = 1，为 0 的话，dp[0] = 0。

字符串长度大于等于 2 时，就需要根据上边的状态转移方程来获取了，最终答案为 dp[n]。

## 代码

```Python
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        for i in range(1, n+1):
            if s[i-1] != '0':
                dp[i] += dp[i-1]
            if i > 1 and s[i-2] != '0' and int(s[i-2:i]) <= 26:
                dp[i] += dp[i-2]
        return dp[n]
```

