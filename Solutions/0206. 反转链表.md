## [0206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

- 标签：链表
- 难度：简单

## 题目大意

给定一个单链表的头节点 `head`。

要求：将该单链表进行反转。可以迭代或递归地反转链表。

比如：

```
翻转前：
1->2->3->4->5->NULL
反转后：
5->4->3->2->1->NULL
```

## 解题思路

### 1. 迭代

顺序遍历当前节点，将当前节点的前后指针进行交换，也就是将当前节点的 `next` 指针指向前一个节点。

由于当前节点没有引用前一个节点，所以在更改指针指向之前必须先把前一个节点保存下来。并且由于更改之后，当前节点的后一个节点失去了引用，所以更改指针指向前，还要将当前节点的后一个节点保存下来。

所以指针更替顺序为：

1. 保存前一个节点 `prev`；
2. 遍历到当前节点 `curr`；
3. 保存当前节点 `curr` 的后一个节点 `next`；
4. 当前节点的 `next` 指针指向前一个节点；
5. 前一个节点 `prev` 移动到当前节点（保存前一个节点）；
6. 当前节点继续向后遍历到 next 位置（遍历当前节点）。
7. 继续执行 3、4、5、6。

上述步骤执行到第 4 步时，当前节点 `curr` 和 `next` 就完成了反转，此时 `next` 指向了 `curr`，继续向下执行，就会不断的进行反转。最后返回新的头节点。

### 2. 递归

假设链表为 $n_1 → n_2 → … → n_{k-1} → n_k → n_{k+1} → … → n_{m-1} → n_m → ∅$ 。

递归将 $n_2 → … → n_{k-1} → n_k → n_{k+1} → … → n_{m-1} → n_m → ∅$ 进行反转，即将 `head.next` 为头节点的链表进行反转，并返回该链表的头节点。然后再改变 `head` 和 `head.next` 的指向关系，完成最终反转。

递归反转其实是通过栈遍历到末尾，先从末尾开始反转，先反转 $n_{m-1} → n_m → ∅$ ，再反转 $n_{m-2} → n_{m-1} → n_m → ∅$，再反转 ...

$n_{m-1} → n_m → ∅$ 反转的顺序为：

1. $n_{n-1}$ 的  `next` 的 `next` （即 $n_m$）指向 $n_{m-1}$。
2. 再将 $n_{m-1}$ 的 `next` 指向 $∅$。
3. 返回新的头节点 $n_m$。

这样就变成了 $∅ ← n_{m-1} ← n_m$，就完成了末尾的反转。

从末尾再依次顺着递归栈的退出，将整个链表进行反转。最后返回新链表的头节点。

## 代码

1. 迭代

```Python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head
        while curr != None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```

2. 递归

```Python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head == None or head.next == None:
            return head
        newHead = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return newHead
```

## 参考资料

- 【题解】[反转链表 - 反转链表 - 力扣](https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/)
